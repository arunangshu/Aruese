<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Type Aruese!</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            -webkit-text-size-adjust: 100%;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            height: 100vh;
            max-height: calc(100vh - 40px);
            overflow: hidden;
            width: 100%;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: clamp(1.5rem, 4vw, 2rem);
            margin-bottom: 0.5rem;
        }

        .header p {
            font-size: clamp(0.8rem, 2vw, 1rem);
            margin: 0;
        }

        .svg-display {
            width: 100%;
            height: 100%;
            min-height: 0;
            display: block;
        }

        .typing-area {
            flex: 1;
            background: white;
            border-radius: 15px;
            padding: 5px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            min-height: 0;
            position: relative;
            display: flex;
        }

        .keyboard {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 10px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            overflow: hidden;
            flex-shrink: 0;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: nowrap;
            width: 100%;
            max-width: 850px;
            margin-left: auto;
            margin-right: auto;
        }

        .key {
            background: linear-gradient(145deg, #f0f0f0, #e6e6e6);
            border: none;
            border-radius: 8px;
            padding: 12px 4px;
            min-width: 45px;
            max-width: 65px;
            min-height: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            position: relative;
            flex: 1;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        .key:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
            background: linear-gradient(145deg, #f5f5f5, #ebebeb);
        }

        .key:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .key.pressed {
            background: linear-gradient(145deg, #d0d0d0, #c6c6c6);
            transform: translateY(1px);
        }

        .key-label {
            font-size: 10px;
            color: #666;
            margin-bottom: 2px;
        }

        .key-glyph {
            width: 24px;
            height: 24px;
        }

        .key-glyph svg {
            width: 100%;
            height: 100%;
        }

        .special-key {
            background: linear-gradient(145deg, #e0e0e0, #d6d6d6);
            color: #444;
            font-size: 12px;
            max-width: 120px;
            flex: 1.5;
        }

        .space-key {
            max-width: 200px;
            flex: 3;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .download-btn, .customize-btn {
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
        }

        .customize-btn {
            background: linear-gradient(145deg, #2196F3, #1976D2);
        }

        .download-btn:hover, .customize-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
        }

        .error-fallback {
            color: #ff6b6b;
            font-size: 16px;
            border: 2px dashed #ff6b6b;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(255, 107, 107, 0.1);
        }

        /* Dialog styles */
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .dialog {
            background: white;
            border-radius: 12px;
            padding: 24px;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .dialog h3 {
            margin-bottom: 16px;
            color: #333;
        }

        .dialog-group {
            margin-bottom: 16px;
        }

        .dialog-group label {
            display: block;
            margin-bottom: 4px;
            font-weight: bold;
            color: #555;
        }

        .dialog-group input {
            width: 100%;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            touch-action: manipulation;
            font-size: 16px; /* Prevent iOS zoom on focus */
        }

        .dialog-group input:focus {
            outline: none;
            border-color: #4CAF50;
        }

        .dialog-buttons {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .dialog-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
        }

        .dialog-btn.primary {
            background: #4CAF50;
            color: white;
        }

        .dialog-btn.secondary {
            background: #ddd;
            color: #333;
        }

        .dialog-btn:hover {
            opacity: 0.9;
        }

        /* Customize mode styles */
        .customize-mode .glyph-element {
            cursor: pointer;
            stroke: rgba(0, 0, 255, 0.3);
            stroke-width: 2;
            fill: none;
        }

        .customize-mode .glyph-element:hover {
            stroke: rgba(0, 0, 255, 0.6);
            stroke-width: 3;
        }

        .customize-mode .glyph-element.selected {
            stroke: #ff4444;
            stroke-width: 3;
        }

        .cursor-line {
            stroke: #333;
            stroke-width: 2;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
		
		.resize-handle {
			cursor: nw-resize !important;
		}

		.customize-mode .glyph-element {
			cursor: move !important;
		}

        /* Add these new mobile-friendly styles */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .container {
                gap: 10px;
                max-height: calc(100vh - 20px);
            }

            .typing-area {
                padding: 15px;
                min-height: 0;
            }

            .keyboard {
                padding: 5px;
            }

            .controls {
                gap: 10px;
                margin-top: 5px;
            }

            .key {
                padding: 8px 2px;
                min-width: 0;
                min-height: 36px;
                font-size: 12px;
            }

            .key-label {
                font-size: 8px;
            }

            .key-glyph {
                width: 18px;
                height: 18px;
            }

            .space-key {
                flex: 3;
            }

            .special-key {
                font-size: 10px;
                flex: 1.5;
            }
        }

        @media (max-width: 480px) {
            .key {
                padding: 4px 1px;
                min-height: 32px;
                font-size: 10px;
            }

            .space-key {
                flex: 4;
            }

            .key-glyph {
                width: 16px;
                height: 16px;
            }

            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .download-btn, .customize-btn {
                width: 100%;
            }

            .key > div {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                width: 100%;
            }
        }

        @media (max-height: 700px) {
            .header {
                margin-bottom: 5px;
            }

            .header h1 {
                font-size: clamp(1.2rem, 3vw, 1.5rem);
                margin-bottom: 0.2rem;
            }

            .header p {
                font-size: clamp(0.7rem, 1.5vw, 0.9rem);
            }

            .typing-area {
                padding: 10px;
            }

            .key {
                min-height: 40px;
            }
		}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Aruese ProtoTyping</h1>
        </div>

        <div class="typing-area">
            <svg class="svg-display" id="svgDisplay" viewBox="0 0 1200 800" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <style type="text/css">
                        .glyph { transform-origin: center; }
                    </style>
                </defs>
                <line id="cursor" class="cursor-line" x1="20" y1="0" x2="20" y2="40"></line>
            </svg>
        </div>

        <div class="keyboard">
            <div class="keyboard-row">
                <button class="key" data-key="q" data-script="aa">
                    <div>
                        <div class="key-label">Q</div>
                        <div class="key-glyph" id="glyph-aa"></div>
                    </div>
                </button>
                <button class="key" data-key="w" data-script="ai">
                    <div>
                        <div class="key-label">W</div>
                        <div class="key-glyph" id="glyph-ai"></div>
                    </div>
                </button>
                <button class="key" data-key="e" data-script="au">
                    <div>
                        <div class="key-label">E</div>
                        <div class="key-glyph" id="glyph-au"></div>
                    </div>
                </button>
                <button class="key" data-key="r" data-script="o">
                    <div>
                        <div class="key-label">R</div>
                        <div class="key-glyph" id="glyph-o"></div>
                    </div>
                </button>
                <button class="key" data-key="t" data-script="u">
                    <div>
                        <div class="key-label">T</div>
                        <div class="key-glyph" id="glyph-u"></div>
                    </div>
                </button>
                <button class="key" data-key="y" data-script="i">
                    <div>
                        <div class="key-label">Y</div>
                        <div class="key-glyph" id="glyph-i"></div>
                    </div>
                </button>
                <button class="key" data-key="u" data-script="e">
                    <div>
                        <div class="key-label">U</div>
                        <div class="key-glyph" id="glyph-e"></div>
                    </div>
                </button>
                <button class="key" data-key="i" data-script="a">
                    <div>
                        <div class="key-label">I</div>
                        <div class="key-glyph" id="glyph-a"></div>
                    </div>
                </button>
                <button class="key" data-key="o" data-script="eu">
                    <div>
                        <div class="key-label">O</div>
                        <div class="key-glyph" id="glyph-eu"></div>
                    </div>
                </button>
                <button class="key" data-key="p" data-script="">
                    <div>
                        <div class="key-label">P</div>
                        <div style="font-size: 10px;">unassigned</div>
                    </div>
                </button>
            </div>

            <div class="keyboard-row">
                <button class="key" data-key="a" data-script="g">
                    <div>
                        <div class="key-label">A</div>
                        <div class="key-glyph" id="glyph-g"></div>
                    </div>
                </button>
                <button class="key" data-key="s" data-script="j">
                    <div>
                        <div class="key-label">S</div>
                        <div class="key-glyph" id="glyph-j"></div>
                    </div>
                </button>
                <button class="key" data-key="d" data-script="dd">
                    <div>
                        <div class="key-label">D</div>
                        <div class="key-glyph" id="glyph-dd"></div>
                    </div>
                </button>
                <button class="key" data-key="f" data-script="d">
                    <div>
                        <div class="key-label">F</div>
                        <div class="key-glyph" id="glyph-d"></div>
                    </div>
                </button>
                <button class="key" data-key="g" data-script="b">
                    <div>
                        <div class="key-label">G</div>
                        <div class="key-glyph" id="glyph-b"></div>
                    </div>
                </button>
                <button class="key" data-key="h" data-script="v">
                    <div>
                        <div class="key-label">H</div>
                        <div class="key-glyph" id="glyph-v"></div>
                    </div>
                </button>
                <button class="key" data-key="j" data-script="l">
                    <div>
                        <div class="key-label">J</div>
                        <div class="key-glyph" id="glyph-l"></div>
                    </div>
                </button>
                <button class="key" data-key="k" data-script="bd">
                    <div>
                        <div class="key-label">K</div>
                        <div class="key-glyph" id="glyph-bd"></div>
                    </div>
                </button>
                <button class="key" data-key="l" data-script="dj">
                    <div>
                        <div class="key-label">L</div>
                        <div class="key-glyph" id="glyph-dj"></div>
                    </div>
                </button>
            </div>

            <div class="keyboard-row">
                <button class="key" data-key="z" data-script="dot-above">
                    <div>
                        <div class="key-label">Z</div>
                        <div class="key-glyph" id="glyph-dot-above"></div>
                        <div style="font-size: 8px;">above</div>
                    </div>
                </button>
                <button class="key" data-key="x" data-script="dot-middle">
                    <div>
                        <div class="key-label">X</div>
                        <div class="key-glyph" id="glyph-dot-middle"></div>
                        <div style="font-size: 8px;">middle</div>
                    </div>
                </button>
                <button class="key" data-key="c" data-script="h">
                    <div>
                        <div class="key-label">C</div>
                        <div class="key-glyph" id="glyph-h"></div>
                    </div>
                </button>
                <button class="key" data-key="v" data-script="v-transform">
                    <div>
                        <div class="key-label">V</div>
                        <div style="font-size: 16px;">↕</div>
                    </div>
                </button>
                <button class="key" data-key="b" data-script="">
                    <div>
                        <div class="key-label">B</div>
                        <div style="font-size: 16px;">✕</div>
                    </div>
                </button>
                <button class="key" data-key="n" data-script="!">
                    <div>
                        <div class="key-label">N</div>
                        <div class="key-glyph" id="glyph-!"></div>
                    </div>
                </button>
                <button class="key" data-key="m" data-script="!i">
                    <div>
                        <div class="key-label">M</div>
                        <div class="key-glyph" id="glyph-!i"></div>
                    </div>
                </button>
                <button class="key" data-key="-" data-script="asp">
                    <div>
                        <div class="key-label">-</div>
                        <div class="key-glyph" id="glyph-asp"></div>
                    </div>
                </button>
            </div>

            <div class="keyboard-row">
                <button class="key special-key" data-key="Backspace">Backspace</button>
                <button class="key special-key space-key" data-key=" ">Space</button>
                <button class="key special-key" data-key="Enter">Enter</button>
            </div>
        </div>

        <div class="controls">
            <button class="download-btn" onclick="downloadSVG()">Download SVG</button>
            <button class="download-btn" onclick="showPngDialog()">Download PNG</button>
            <button class="customize-btn" onclick="toggleCustomizeMode()">Customize</button>
        </div>
    </div>

    <!-- PNG Resolution Dialog -->
    <div class="dialog-overlay" id="pngDialog">
        <div class="dialog">
            <h3>PNG Export Settings</h3>
            <div class="dialog-group">
                <label for="lineHeight">Line Height (pixels):</label>
                <input type="number" id="lineHeight" value="70" min="20" max="200">
            </div>
            <div class="dialog-buttons">
                <button class="dialog-btn secondary" onclick="closePngDialog()">Cancel</button>
                <button class="dialog-btn primary" onclick="downloadPNG()">Download</button>
            </div>
        </div>
    </div>

    <!-- Character Customization Dialog -->
    <div class="dialog-overlay" id="customizeDialog">
        <div class="dialog">
            <h3>Customize Character</h3>
            <div class="dialog-group">
                <label for="translateX">Translate X:</label>
                <input type="number" id="translateX" value="0" step="0.1">
            </div>
            <div class="dialog-group">
                <label for="translateY">Translate Y:</label>
                <input type="number" id="translateY" value="0" step="0.1">
            </div>
            <div class="dialog-group">
                <label for="scaleX">Scale X:</label>
                <input type="number" id="scaleX" value="1" step="0.1" min="0.1">
            </div>
            <div class="dialog-group">
                <label for="scaleY">Scale Y:</label>
                <input type="number" id="scaleY" value="1" step="0.1" min="0.1">
            </div>
            <div class="dialog-group">
                <label for="stretchX">Stretch X:</label>
                <input type="number" id="stretchX" value="1" step="0.1" min="0.1">
            </div>
            <div class="dialog-group">
                <label for="stretchY">Stretch Y:</label>
                <input type="number" id="stretchY" value="1" step="0.1" min="0.1">
            </div>
            <div class="dialog-buttons">
                <button class="dialog-btn secondary" onclick="closeCustomizeDialog()">Cancel</button>
                <button class="dialog-btn primary" onclick="applyCustomization()">Apply</button>
            </div>
        </div>
    </div>

    <script>
        let textContent = [];
        let cursorPosition = 0;
        const SVG_INITIAL_PADDING = 5; // Padding inside SVG content (top, left)
        const SVG_BOTTOM_PADDING = 20; // Extra padding at the bottom of SVG content
        const SVG_CHAR_SPACING = 5;    // Horizontal space between characters
        const SVG_INTERNAL_CONTENT_WIDTH = 1150; // Logical width for line wrapping

        let glyphHeight = 50; // Base height for glyphs
        let lineHeight = glyphHeight * 1.3; // Line height relative to glyph height
        
        let currentX = SVG_INITIAL_PADDING; // Initial X for cursor if text empty
        let currentY = SVG_INITIAL_PADDING; // Initial Y (top of char box) for cursor if text empty

        let customizeMode = false;
        let selectedGlyph = null;

        const keyMapping = {
            'q': 'aa', 'w': 'ai', 'e': 'au', 'r': 'o', 't': 'u',
            'y': 'i', 'u': 'e', 'i': 'a', 'o': 'eu', 'p': '',
            'a': 'g', 's': 'j', 'd': 'dd', 'f': 'd', 'g': 'b',
            'h': 'v', 'j': 'l', 'k': 'bd', 'l': 'dj',
            'z': 'dot-above', 'x': 'dot-middle', 'c': 'h', 'v': 'v-transform', 'b': '',
            'n': '!', 'm': '!i', '-': 'asp'
        };

        let dotSvg = null;

        // Mapping for V key transformations
        const vKeyTransformations = {
            'g': 'ghy', 'j': 'zh', 'dd': 'rd', 'd': 'z', 'b': 'bhy',
            'v': 'w', 'l': 'r', 'bd': 'zv', 'dj': 'zzh'
        };

		let isDragging = false;
		let isResizing = false;
		let dragStartPos = { x: 0, y: 0 };
		let dragOffset = { x: 0, y: 0 };
		let resizeStartPos = { x: 0, y: 0 };
		let resizeStartScale = { x: 1, y: 1 };
		let activeGlyph = null;
		let resizeHandle = null;
		
        async function loadDotSvg() {
            if (!dotSvg) {
                dotSvg = await loadGlyph('dot');
            }
            return dotSvg;
        }

        async function loadGlyph(scriptChar) {
            if (!scriptChar || scriptChar === '') return null;
            
            try {
                const response = await fetch(`glyph/svg/${scriptChar}.svg`);
                if (!response.ok) throw new Error(`Failed to load ${scriptChar}.svg`);
                const svgText = await response.text();
                return svgText;
            } catch (error) {
                console.warn(`Could not load glyph for ${scriptChar}:`, error);
                return null;
            }
        }

        async function initializeKeyboard() {
            await loadDotSvg();
            
            for (const [key, scriptChar] of Object.entries(keyMapping)) {
                if (scriptChar && scriptChar !== '') {
                    let glyphElement;
                    if (scriptChar === 'dot-above' || scriptChar === 'dot-middle') {
                        glyphElement = document.getElementById(`glyph-${scriptChar}`);
                        if (glyphElement && dotSvg) {
                            glyphElement.innerHTML = dotSvg;
                        }
                    } else {
                        glyphElement = document.getElementById(`glyph-${scriptChar}`);
                        if (glyphElement) {
                            const svgContent = await loadGlyph(scriptChar);
                            if (svgContent) {
                                glyphElement.innerHTML = svgContent;
                            } else {
                                glyphElement.innerHTML = `<div class="error-fallback">${scriptChar}</div>`;
                            }
                        }
                    }
                }
            }
        }

        function updateSVGDisplay() {
			const svgDisplay = document.getElementById('svgDisplay');
			const cursor = document.getElementById('cursor');
            const typingArea = document.querySelector('.typing-area');
			
			// Clear existing glyphs and resize handles
			const existingGlyphs = svgDisplay.querySelectorAll('.glyph-element');
			const existingHandles = svgDisplay.querySelectorAll('.resize-handle');
			existingGlyphs.forEach(g => g.remove());
			existingHandles.forEach(h => h.remove());
			
            let x = SVG_INITIAL_PADDING;
            let y = SVG_INITIAL_PADDING; // y is the top of the current line's character bounding boxes
            
            let contentMaxX = SVG_INITIAL_PADDING; 
            let contentMaxY = SVG_INITIAL_PADDING + glyphHeight; // Min height for one line if text is empty

            if (textContent.length === 0) {
                if (cursorPosition === 0) {
                    cursor.setAttribute('x1', x);
                    cursor.setAttribute('x2', x);
                    cursor.setAttribute('y1', y);
                    cursor.setAttribute('y2', y + glyphHeight);
                }
                // For empty content, ensure bottom padding is included in default viewbox height
                svgDisplay.setAttribute('viewBox', `0 0 ${Math.max(100, contentMaxX)} ${contentMaxY + SVG_BOTTOM_PADDING}`);
                return;
            }
            
            // Recalculate contentMaxX and contentMaxY based on actual content
            contentMaxX = SVG_INITIAL_PADDING;
            contentMaxY = SVG_INITIAL_PADDING; // Will be updated to y + glyphHeight of last line

            for (let i = 0; i <= textContent.length; i++) {
                // CURSOR POSITIONING
				if (i === cursorPosition) {
					cursor.setAttribute('x1', x);
					cursor.setAttribute('x2', x);
                    cursor.setAttribute('y1', y); 
                    cursor.setAttribute('y2', y + glyphHeight); 
				}

                if (i >= textContent.length) continue; 

                const item = textContent[i];
                let charActualRenderedWidth = 0;
				
				if (item.type === 'glyph' && item.svg) {
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = item.svg;
                    const tempSvg = tempDiv.querySelector('svg');
                    const naturalWidth = parseFloat(tempSvg?.getAttribute('width') || tempSvg?.getAttribute('viewBox')?.split(' ')[2] || glyphHeight);
                    const naturalHeight = parseFloat(tempSvg?.getAttribute('height') || tempSvg?.getAttribute('viewBox')?.split(' ')[3] || glyphHeight);
                    const aspectRatio = (naturalHeight === 0 || naturalWidth === 0) ? 1 : naturalWidth / naturalHeight;
                    
                    charActualRenderedWidth = glyphHeight * aspectRatio;
                    const glyphScaleToFixedHeight = (naturalHeight === 0) ? 1 : glyphHeight / naturalHeight;

					const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
					g.classList.add('glyph-element');
					g.setAttribute('data-index', i);
					g.style.cursor = customizeMode ? 'move' : 'default';
					
                    let transformString = `translate(${x + (item.customTransform?.translateX || 0)}, ${y + (item.customTransform?.translateY || 0)})`;
					
					if (item.customTransform) {
						const scaleX = item.customTransform.scaleX || 1;
						const scaleY = item.customTransform.scaleY || 1;
                        transformString += ` scale(${glyphScaleToFixedHeight * scaleX}, ${glyphScaleToFixedHeight * scaleY})`;
                        charActualRenderedWidth *= scaleX; 
                    } else {
                        transformString += ` scale(${glyphScaleToFixedHeight})`;
                    }
                    
                    g.setAttribute('transform', transformString);
                    
					const svgContent = item.svg
                        .replace(/<\\?xml[^>]*\\?>/, '')
						.replace(/<svg[^>]*>/, '')
						.replace('</svg>', '');
					
					g.innerHTML = svgContent;
					svgDisplay.appendChild(g);
					
                    x += charActualRenderedWidth + SVG_CHAR_SPACING;

				} else if (item.type === 'dot-above' || item.type === 'dot-middle') {
                    const prevGlyphElement = svgDisplay.querySelector(`.glyph-element[data-index="${i-1}"]`);
                    if (prevGlyphElement && item.svg) {
						const dotG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        const dotScale = glyphHeight / 50; 
                        const baseGlyphTransform = prevGlyphElement.transform.baseVal.consolidate(); // Get the actual matrix
                        const baseGlyphWidth = prevGlyphElement.getBBox().width / (baseGlyphTransform ? baseGlyphTransform.matrix.a : 1) ; // Approx unscaled width of base

                        const dotXOffset = baseGlyphWidth / 2; // Center dot on the base glyph
                        const dotYOffset = item.type === 'dot-above' ? -glyphHeight * 0.1 : glyphHeight * 0.5; // Adjusted for top-relative placement
                        
                        // Transform for dot is relative to its parent g element (the base glyph)
                        // The dot's own SVG content has its origin, so we translate and scale it.
                        dotG.setAttribute('transform', `translate(${dotXOffset}, ${dotYOffset}) scale(${dotScale})`);
                        
                        const svgContent = item.svg.replace(/<\\?xml[^>]*\\?>/, '').replace(/<svg[^>]*>/, '').replace('</svg>', '');
						dotG.innerHTML = svgContent;
                        prevGlyphElement.appendChild(dotG);
                        // Dots don't advance x; they are part of the previous character.
					}
				} else if (item.type === 'space') {
                    charActualRenderedWidth = glyphHeight * 0.4; // Space width relative to height
                    x += charActualRenderedWidth + SVG_CHAR_SPACING;
				} else if (item.type === 'newline') {
                    x = SVG_INITIAL_PADDING;
					y += lineHeight;
                    charActualRenderedWidth = 0; // Newline doesn't have width on current line
                }
                
                contentMaxX = Math.max(contentMaxX, x);
                contentMaxY = Math.max(contentMaxY, y + glyphHeight);
                
                if (item.type !== 'newline' && x > (SVG_INTERNAL_CONTENT_WIDTH - SVG_INITIAL_PADDING) && i < textContent.length - 1) {
                    x = SVG_INITIAL_PADDING;
					y += lineHeight;
                    contentMaxY = Math.max(contentMaxY, y + glyphHeight); // Update maxY for new line
                }
            }
            
            // Add bottom padding to contentMaxY before setting viewBox
            contentMaxY += SVG_BOTTOM_PADDING;
            svgDisplay.setAttribute('viewBox', `0 0 ${Math.max(SVG_INITIAL_PADDING + 100, contentMaxX)} ${Math.max(SVG_INITIAL_PADDING + glyphHeight + SVG_BOTTOM_PADDING, contentMaxY)}`);

            if (customizeMode) {
                const renderedGlyphs = svgDisplay.querySelectorAll('.glyph-element');
                renderedGlyphs.forEach(glyphElement => {
                    const dataIndex = parseInt(glyphElement.getAttribute('data-index'));
                    const item = textContent[dataIndex];
                    if (!item || item.type !== 'glyph') return;

                    const transformList = glyphElement.transform.baseVal;
                    let glyphRenderedX = 0;
                    let glyphRenderedY = 0;
                    if (transformList.length > 0) {
                        const transformMatrix = transformList.getItem(0).matrix;
                        glyphRenderedX = transformMatrix.e;
                        glyphRenderedY = transformMatrix.f;
                    }
                    
                    // Calculate rendered width of this specific glyph for handle placement
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = item.svg;
                    const tempSvg = tempDiv.querySelector('svg');
                    const naturalWidth = parseFloat(tempSvg?.getAttribute('width') || tempSvg?.getAttribute('viewBox')?.split(' ')[2] || glyphHeight);
                    const naturalHeight = parseFloat(tempSvg?.getAttribute('height') || tempSvg?.getAttribute('viewBox')?.split(' ')[3] || glyphHeight);
                    const aspectRatio = (naturalHeight === 0 || naturalWidth === 0) ? 1 : naturalWidth / naturalHeight;
                    let charRenderedWidth = glyphHeight * aspectRatio;
                     if (item.customTransform?.scaleX) {
                        charRenderedWidth *= item.customTransform.scaleX;
                    }

                    const resizeHandle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    resizeHandle.classList.add('resize-handle');
                    resizeHandle.setAttribute('cx', glyphRenderedX + charRenderedWidth); 
                    resizeHandle.setAttribute('cy', glyphRenderedY);                   
                    resizeHandle.setAttribute('r', '6');
                    resizeHandle.setAttribute('fill', '#ff4444');
                    resizeHandle.setAttribute('stroke', '#ffffff');
                    resizeHandle.setAttribute('stroke-width', '2');
                    resizeHandle.setAttribute('data-index', dataIndex);
                    resizeHandle.style.cursor = 'ne-resize'; // Top-right handle
                    resizeHandle.addEventListener('mousedown', (e) => startResize(e, dataIndex));
                    svgDisplay.appendChild(resizeHandle);
                });
            }
        }

        // Add resize observer to update SVG when typing area size changes
        const resizeObserver = new ResizeObserver(() => {
            updateSVGDisplay();
        });

        document.addEventListener('DOMContentLoaded', async () => {
            await initializeKeyboard();
            const typingArea = document.querySelector('.typing-area');
            resizeObserver.observe(typingArea);
            updateSVGDisplay();
        });

		// NEW: Drag functionality
		function startDrag(e, index) {
			if (!customizeMode) return;
			e.preventDefault();
			e.stopPropagation();
			
			isDragging = true;
			activeGlyph = index;
			
			const svgDisplay = document.getElementById('svgDisplay');
			const rect = svgDisplay.getBoundingClientRect();
			const svgPoint = getSVGPoint(e.clientX, e.clientY, svgDisplay);
			
			const item = textContent[index];
			const currentTransform = item.customTransform || {};
			
			dragStartPos = { x: svgPoint.x, y: svgPoint.y };
			dragOffset = {
				x: currentTransform.translateX || 0,
				y: currentTransform.translateY || 0
			};
			
			document.addEventListener('mousemove', handleDrag);
			document.addEventListener('mouseup', stopDrag);
		}

		function handleDrag(e) {
			if (!isDragging || activeGlyph === null) return;
			
			const svgDisplay = document.getElementById('svgDisplay');
			const svgPoint = getSVGPoint(e.clientX, e.clientY, svgDisplay);
			
			const deltaX = svgPoint.x - dragStartPos.x;
			const deltaY = svgPoint.y - dragStartPos.y;
			
			if (!textContent[activeGlyph].customTransform) {
				textContent[activeGlyph].customTransform = {};
			}
			
			textContent[activeGlyph].customTransform.translateX = dragOffset.x + deltaX;
			textContent[activeGlyph].customTransform.translateY = dragOffset.y + deltaY;
			
			updateSVGDisplay();
		}

		function stopDrag() {
			isDragging = false;
			activeGlyph = null;
			document.removeEventListener('mousemove', handleDrag);
			document.removeEventListener('mouseup', stopDrag);
		}

		// NEW: Resize functionality
		function startResize(e, index) {
			if (!customizeMode) return;
			e.preventDefault();
			e.stopPropagation();
			
			isResizing = true;
			activeGlyph = index;
			
			const svgDisplay = document.getElementById('svgDisplay');
			const svgPoint = getSVGPoint(e.clientX, e.clientY, svgDisplay);
			
			const item = textContent[index];
			const currentTransform = item.customTransform || {};
			
			resizeStartPos = { x: svgPoint.x, y: svgPoint.y };
			resizeStartScale = {
				x: (currentTransform.scaleX || 1) * (currentTransform.stretchX || 1),
				y: (currentTransform.scaleY || 1) * (currentTransform.stretchY || 1)
			};
			
			document.addEventListener('mousemove', handleResize);
			document.addEventListener('mouseup', stopResize);
		}

		function handleResize(e) {
			if (!isResizing || activeGlyph === null) return;
			
			const svgDisplay = document.getElementById('svgDisplay');
			const svgPoint = getSVGPoint(e.clientX, e.clientY, svgDisplay);
			
			const deltaX = svgPoint.x - resizeStartPos.x;
			const deltaY = svgPoint.y - resizeStartPos.y;
			
			// Calculate scale based on distance from original position
			const scaleFactorX = Math.max(0.1, 1 + deltaX / 100);
			const scaleFactorY = Math.max(0.1, 1 + deltaY / 100);
			
			if (!textContent[activeGlyph].customTransform) {
				textContent[activeGlyph].customTransform = {};
			}
			
			textContent[activeGlyph].customTransform.scaleX = resizeStartScale.x * scaleFactorX;
			textContent[activeGlyph].customTransform.scaleY = resizeStartScale.y * scaleFactorY;
			
			updateSVGDisplay();
		}

		function stopResize() {
			isResizing = false;
			activeGlyph = null;
			document.removeEventListener('mousemove', handleResize);
			document.removeEventListener('mouseup', stopResize);
		}

		// NEW: Helper function to get SVG coordinates
		function getSVGPoint(clientX, clientY, svgElement) {
			const pt = svgElement.createSVGPoint();
			pt.x = clientX;
			pt.y = clientY;
			return pt.matrixTransform(svgElement.getScreenCTM().inverse());
		}

        async function addCharacter(scriptChar) {
            if (scriptChar === 'dot-above' || scriptChar === 'dot-middle') {
                const dotSvgContent = await loadDotSvg();
                textContent.splice(cursorPosition, 0, { 
                    type: scriptChar, 
                    char: scriptChar,
                    svg: dotSvgContent 
                });
                cursorPosition++;
            } else if (scriptChar === 'v-transform') {
                await handleVKeyTransformation();
            } else if (scriptChar === '' || !scriptChar) {
                return;
            } else {
                const svg = await loadGlyph(scriptChar);
                let itemToAdd = { 
                    type: 'glyph', 
                    char: scriptChar, 
                    svg: svg 
                };

                if (scriptChar === 'asp' && cursorPosition > 0) {
                    const specialChars = ['g', 'j', 'dd', 'd', 'b', 'v', 'l', 'bd', 'dj', 'dhy', 'zh', 'rd', 'z', 'bhy', 'w', 'r', 'zv', 'zzh'];
                    
                    let prevIndex = cursorPosition - 1;
                    while (prevIndex >= 0 && textContent[prevIndex].type !== 'glyph') {
                        prevIndex--;
                    }
                    
                    if (prevIndex >= 0 && specialChars.includes(textContent[prevIndex].char)) {
                        itemToAdd.className = 'asp-special';
                    } else {
                        itemToAdd.className = 'asp-normal';
                    }
                }

                textContent.splice(cursorPosition, 0, itemToAdd);
                cursorPosition++;
            }
            updateSVGDisplay();
        }

        async function handleVKeyTransformation() {
            if (cursorPosition === 0) return;
            
            let prevIndex = cursorPosition - 1;
            while (prevIndex >= 0 && textContent[prevIndex].type !== 'glyph') {
                prevIndex--;
            }
            
            if (prevIndex < 0) return;
            
            const prevGlyphItem = textContent[prevIndex];

            if (prevGlyphItem.originalCharBeforeVTransform) {
                // Revert to original character
                const originalChar = prevGlyphItem.originalCharBeforeVTransform;
                const newSvg = await loadGlyph(originalChar);
                if (newSvg) {
                    textContent[prevIndex] = {
                        ...prevGlyphItem,
                        char: originalChar,
                        svg: newSvg,
                        originalCharBeforeVTransform: null // Clear the stored original
                    };
                }
            } else {
                // Apply transformation
                const transformation = vKeyTransformations[prevGlyphItem.char];
            if (transformation) {
                    const originalChar = prevGlyphItem.char;
                const newSvg = await loadGlyph(transformation);
                    if (newSvg) {
                textContent[prevIndex] = {
                            ...prevGlyphItem,
                    char: transformation,
                            svg: newSvg,
                            originalCharBeforeVTransform: originalChar // Store the original
                };
            }
                }
            }
            // No need to call updateSVGDisplay() here if addCharacter already does
            // However, if we directly modify textContent, we MUST call it.
            updateSVGDisplay(); 
        }

        function addSpace() {
            textContent.splice(cursorPosition, 0, { type: 'space' });
            cursorPosition++;
            updateSVGDisplay();
        }

        function addNewline() {
            textContent.splice(cursorPosition, 0, { type: 'newline' });
            cursorPosition++;
            updateSVGDisplay();
        }

        function handleBackspace() {
            if (cursorPosition > 0) {
                textContent.splice(cursorPosition - 1, 1);
                cursorPosition--;
                updateSVGDisplay();
            }
        }

        function moveCursor(direction) {
            if (direction === 'left' && cursorPosition > 0) {
                cursorPosition--;
            } else if (direction === 'right' && cursorPosition < textContent.length) {
                cursorPosition++;
            }
            updateSVGDisplay();
        }

        // Keyboard event handlers
        document.addEventListener('keydown', async (e) => {
            // Allow normal typing in dialog inputs
            if (e.target.tagName === 'INPUT') {
                return; // Let the default input behavior work
            }

            // Skip if any modifier key is pressed (Ctrl, Alt, Meta/Command)
            if (e.ctrlKey || e.altKey || e.metaKey) {
                return; // Let the default browser behavior handle the shortcut
            }

            const key = e.key.toLowerCase();
            
            if (e.key === 'Backspace') {
                e.preventDefault();
                handleBackspace();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                addNewline();
            } else if (e.key === ' ') {
                e.preventDefault();
                addSpace();
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                moveCursor('left');
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                moveCursor('right');
            } else if (keyMapping[key] && !e.shiftKey) {
                e.preventDefault();
                const scriptChar = keyMapping[key];
                if (scriptChar) {
                    await addCharacter(scriptChar);
                }
            }
        });

        // Virtual keyboard handlers
        document.addEventListener('click', async (e) => {
            if (e.target.closest('.key')) {
                const keyButton = e.target.closest('.key');
                const key = keyButton.dataset.key;
                const scriptChar = keyButton.dataset.script;
                
                // Visual feedback
                keyButton.classList.add('pressed');
                setTimeout(() => keyButton.classList.remove('pressed'), 150);
                
                if (key === 'Backspace') {
                    handleBackspace();
                } else if (key === 'Enter') {
                    addNewline();
                } else if (key === ' ') {
                    addSpace();
                } else if (scriptChar !== undefined) {
                    if (scriptChar) {
                        await addCharacter(scriptChar);
                    }
                }
            }
        });

        // Download SVG function
        function downloadSVG() {
            const svgDisplay = document.getElementById('svgDisplay');
            const svgClone = svgDisplay.cloneNode(true);
            
            // Remove cursor from clone
            const cursor = svgClone.querySelector('#cursor');
            if (cursor) cursor.remove();
            
            // Get the viewBox from the live SVG (which includes all correct padding)
            const liveViewBox = svgDisplay.getAttribute('viewBox');
            if (!liveViewBox) {
                console.error('Cannot download SVG: viewBox attribute is missing from live SVG.');
                return;
            }

            const viewBoxParts = liveViewBox.split(' ').map(Number);
            const viewBoxWidth = viewBoxParts[2];
            const viewBoxHeight = viewBoxParts[3];

            // Set the width and height attributes of the clone to match its viewBox dimensions
            // The viewBox attribute on svgClone is already correct as it was cloned.
            svgClone.setAttribute('width', viewBoxWidth.toString());
            svgClone.setAttribute('height', viewBoxHeight.toString());
            
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'aruese-text.svg';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // PNG Dialog functions
        function showPngDialog() {
            // Set initial line height value based on current SVG
            const currentLineHeight = Math.round(glyphHeight * 1.3);
            document.getElementById('lineHeight').value = currentLineHeight;
            document.getElementById('pngDialog').style.display = 'flex';
        }

        function closePngDialog() {
            document.getElementById('pngDialog').style.display = 'none';
        }

        function downloadPNG() {
            const customLineHeight = parseInt(document.getElementById('lineHeight').value) || 70;
            const svgDisplay = document.getElementById('svgDisplay');
            const svgClone = svgDisplay.cloneNode(true);
            
            // Remove cursor from clone
            const cursor = svgClone.querySelector('#cursor');
            if (cursor) cursor.remove();
            
            // Get the current viewBox values
            const viewBox = svgDisplay.getAttribute('viewBox').split(' ').map(Number);
            const viewBoxWidth = viewBox[2];
            const viewBoxHeight = viewBox[3];

            // Calculate the scale factor based on the desired line height
            const scaleFactor = customLineHeight / glyphHeight;
            
            // Set dimensions for the PNG
            const pngWidth = Math.ceil(viewBoxWidth * scaleFactor);
            const pngHeight = Math.ceil(viewBoxHeight * scaleFactor);

            // Create canvas with the calculated dimensions
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = pngWidth;
            canvas.height = pngHeight;

            // Set white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Prepare SVG string with explicit dimensions
            svgClone.setAttribute('width', pngWidth);
            svgClone.setAttribute('height', pngHeight);
            
            // Ensure viewBox is preserved
            svgClone.setAttribute('viewBox', `0 0 ${viewBoxWidth} ${viewBoxHeight}`);
            svgClone.setAttribute('preserveAspectRatio', 'xMinYMin meet');

            const svgString = new XMLSerializer().serializeToString(svgClone);
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const URL = window.URL || window.webkitURL || window;
            const blobURL = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0, pngWidth, pngHeight);
                URL.revokeObjectURL(blobURL);

                // Convert to PNG and download
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'aruese-text.png';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 'image/png');
            };
            
            img.src = blobURL;
            closePngDialog();
        }

        function toggleCustomizeMode() {
			customizeMode = !customizeMode;
			const button = document.querySelector('.customize-btn');
			const svgDisplay = document.getElementById('svgDisplay');
			
			if (customizeMode) {
				button.textContent = 'Exit Customize';
				button.style.background = 'linear-gradient(145deg, #ff6b6b, #ee5a5a)';
				svgDisplay.classList.add('customize-mode');
				selectedGlyph = null;
			} else {
				button.textContent = 'Customize';
				button.style.background = 'linear-gradient(145deg, #2196F3, #1976D2)';
				svgDisplay.classList.remove('customize-mode');
				selectedGlyph = null;
				// Stop any ongoing drag/resize
				isDragging = false;
				isResizing = false;
				activeGlyph = null;
				document.removeEventListener('mousemove', handleDrag);
				document.removeEventListener('mouseup', stopDrag);
				document.removeEventListener('mousemove', handleResize);
				document.removeEventListener('mouseup', stopResize);
			}
			updateSVGDisplay();
		}

        function selectGlyph(index) {
            if (!customizeMode) return;
            
            const svgDisplay = document.getElementById('svgDisplay');
            const selected = svgDisplay.querySelectorAll('.glyph-element.selected');
            selected.forEach(el => el.classList.remove('selected'));
            
            const glyph = svgDisplay.querySelector(`.glyph-element[data-index="${index}"]`);
            if (glyph) {
                glyph.classList.add('selected');
                selectedGlyph = index;
                showCustomizeDialog();
            }
        }

        function showCustomizeDialog() {
            if (selectedGlyph === null) return;
            
            const item = textContent[selectedGlyph];
            const transform = item.customTransform || {};
            
            document.getElementById('translateX').value = transform.translateX || 0;
            document.getElementById('translateY').value = transform.translateY || 0;
            document.getElementById('scaleX').value = transform.scaleX || 1;
            document.getElementById('scaleY').value = transform.scaleY || 1;
            document.getElementById('stretchX').value = transform.stretchX || 1;
            document.getElementById('stretchY').value = transform.stretchY || 1;
            
            document.getElementById('customizeDialog').style.display = 'flex';
        }

        function closeCustomizeDialog() {
            document.getElementById('customizeDialog').style.display = 'none';
        }

        function applyCustomization() {
            if (selectedGlyph === null) {
                closeCustomizeDialog();
                return;
            }
            
            const translateX = parseFloat(document.getElementById('translateX').value) || 0;
            const translateY = parseFloat(document.getElementById('translateY').value) || 0;
            const scaleX = parseFloat(document.getElementById('scaleX').value) || 1;
            const scaleY = parseFloat(document.getElementById('scaleY').value) || 1;
            const stretchX = parseFloat(document.getElementById('stretchX').value) || 1;
            const stretchY = parseFloat(document.getElementById('stretchY').value) || 1;
            
            if (!textContent[selectedGlyph].customTransform) {
                textContent[selectedGlyph].customTransform = {};
            }
            
            textContent[selectedGlyph].customTransform = {
                translateX: translateX,
                translateY: translateY,
                scaleX: scaleX,
                scaleY: scaleY,
                stretchX: stretchX,
                stretchY: stretchY
            };
            
            updateSVGDisplay();
            closeCustomizeDialog();
        }

        // Function to request full screen
        function requestFullScreen() {
            const element = document.documentElement;
            
            if (element.requestFullscreen) {
                element.requestFullscreen();
            } else if (element.webkitRequestFullscreen) { // Safari
                element.webkitRequestFullscreen();
            } else if (element.msRequestFullscreen) { // IE11
                element.msRequestFullscreen();
            }
        }

        // Check if device is mobile and request full screen on first interaction
        document.addEventListener('DOMContentLoaded', () => {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            
            if (isMobile) {
                // Add a one-time click listener to the body
                document.body.addEventListener('click', function handleFirstClick() {
                    requestFullScreen();
                    // Remove the listener after first click
                    document.body.removeEventListener('click', handleFirstClick);
                }, { once: true });
            }
        });
    </script>
</body>
</html>